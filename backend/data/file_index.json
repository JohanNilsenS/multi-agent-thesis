{
  "app.py": "# app.py\nfrom flask import Flask\nfrom src import create_app\n\napp = create_app()\n\nif __name__ == \"__main__\":\n    app.run(debug=True)",
  "test_internet.py": "from src.model.tools.internet_search import search_duckduckgo\n\nresults = search_duckduckgo(\"how does langchain memory work?\")\nfor r in results:\n    print(\"\\n---\\n\" + r)\n",
  "test_supervisor.py": "# test_supervisor.py\n\nfrom src.model.supervisor import SupervisorAgent\nfrom src.model.tools.internet_search import search_duckduckgo\n\ntest_research = False\ntest_git = False\ninternet_search = True\ndef main():\n    supervisor = SupervisorAgent()\n\n    # After creating the supervisor and running a task\n    git_agent = next(agent for agent in supervisor.agents if agent.name == \"GitAgent\")\n    git_agent.print_file_index_preview()\n\n    if test_research:\n        task = \"research why flamingos are pink\"\n        result = supervisor.delegate(task)\n\n        print(f\"Task Source: {result['source']}\")\n        print(\"Content:\")\n        print(result['content'])\n\n        print(\"\\n--- Running same task again to test DB retrieval ---\\n\")\n        result = supervisor.delegate(task)\n        print(f\"Task Source: {result['source']}\")\n        print(\"Content:\")\n        print(result['content'])\n\n\n    if test_git:\n        print(\"\\n--- Git Commit Summary ---\\n\")\n        result = supervisor.delegate(\"git summary\")\n        print(result)\n\n        print(\"\\n--- Project Overview ---\\n\")\n        result = supervisor.delegate(\"project overview\")\n        print(result)\n\n        print(\"\\n--- Suggestions ---\\n\")\n        result = supervisor.delegate(\"suggest improvement\")\n        print(result)\n\n        print(\"\\n--- Explain Function: process_invoice ---\\n\")\n        git_agent.reindex_files()\n        explanation = git_agent.explain_function(\"explain_function\")\n        print(explanation)\n\n        print(\"\\n--- All Indexed Functions ---\\n\")\n        for func in git_agent.list_all_functions():\n            print(f\"{func['name']}  \u279c  {func['path']}\")\n\n    if internet_search:\n        queries = [\n            \"research how to build a supervisor agent system in python\",\n            \"research why the world is round\"\n        ]\n\n        for query in queries:\n            print(f\"\\n--- Research: {query} ---\")\n            result = supervisor.delegate(query)\n            print(f\"Source: {result['source']}\")\n            print(f\"Content:\\n{result['content']}\")\n\n\n\nif __name__ == \"__main__\":\n    main()\n",
  "src\\__init__.py": "import os\nfrom flask import Flask, send_from_directory\n\ndef create_app():\n    app = Flask(__name__)\n\n    # Register your API routes\n    from .routes import status\n    app.register_blueprint(status.bp)\n    from .routes import supervisorroute\n    app.register_blueprint(supervisorroute.bp)\n    from .routes import knowledge\n    app.register_blueprint(knowledge.bp)\n\n    # Serve React frontend from frontend/dist\n    @app.route(\"/\", defaults={\"path\": \"\"})\n    @app.route(\"/<path:path>\")\n    def serve_react(path):\n        dist_dir = os.path.join(os.path.dirname(__file__), \"..\", \"frontend\", \"dist\")\n        target = os.path.join(dist_dir, path)\n\n        if path != \"\" and os.path.exists(target):\n            return send_from_directory(dist_dir, path)\n        else:\n            return send_from_directory(dist_dir, \"index.html\")\n\n    return app\n",
  "src\\model\\base_agent.py": "# src/model/base_agent.py\n\nclass BaseAgent:\n    def __init__(self, name: str):\n        self.name = name\n\n    def can_handle(self, task: str) -> bool:\n        \"\"\"Determine if this agent can handle the given task.\"\"\"\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    def handle(self, task: str, **kwargs):\n        \"\"\"Handle the task and return a response.\"\"\"\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n",
  "src\\model\\llm_client.py": "# src/model/llm_client.py\n\nimport os\nimport requests\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nclass LLMClient:\n    def __init__(self):\n        self.base_url = os.getenv(\"LLM_ENDPOINT\")\n        self.api_key = os.getenv(\"LLM_API_KEY\")\n        self.headers = {\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": f\"Bearer {self.api_key}\"  # Try \"Api-Key\" if this fails\n        }\n\n    def query(self, user_prompt: str, system_prompt: str = \"You are a helpful assistant.\", **kwargs) -> str:\n        payload = {\n            \"messages\": [\n                {\"role\": \"system\", \"content\": system_prompt},\n                {\"role\": \"user\", \"content\": user_prompt}\n            ],\n            \"temperature\": 0.2,\n            \"max_tokens\": 2048,\n            **kwargs\n        }\n        try:\n            response = requests.post(self.base_url, json=payload, headers=self.headers)\n            response.raise_for_status()\n            data = response.json()\n            return data[\"choices\"][0][\"message\"][\"content\"]\n        except requests.RequestException as e:\n            print(f\"[LLMClient] Error: {e}\")\n            return f\"Error querying LLM: {e}\"\n",
  "src\\model\\supervisor.py": "# src/model/supervisor.py\n\nfrom src.model.base_agent import BaseAgent\nfrom src.model.agents.research_agent import ResearchAgent\nfrom src.model.agents.git_agent import GitAgent\nfrom src.model.llm_client import LLMClient\nimport os\n\nclass SupervisorAgent:\n    def __init__(self):\n        self.agents: list[BaseAgent] = []\n\n        # Setup: shared in-memory DB and LLM client\n        self.database = {}\n        self.llm = LLMClient()\n\n        # Register sub-agents\n        self.register_agent(ResearchAgent(self.database, self.llm))\n\n        # Set repo path (use current project root as default)\n        repo_path = os.path.abspath(\".\")\n        self.register_agent(GitAgent(repo_path, self.llm))\n\n    def register_agent(self, agent: BaseAgent):\n        self.agents.append(agent)\n\n    def decide_agent(self, task: str) -> BaseAgent | None:\n        prompt = (\n            f\"You are a routing assistant in a multi-agent system.\\n\"\n            f\"Here is the user task:\\n\\n\\\"{task}\\\"\\n\\n\"\n            \"Based on this, which of the following agents should handle it?\\n\"\n            \"- ResearchAgent: answers questions or gathers external information\\n\"\n            \"- GitAgent: explains code, analyzes commits, explores repositories\\n\\n\"\n            \"Respond with only the agent name: ResearchAgent or GitAgent.\"\n        )\n        decision = self.llm.query(prompt).strip()\n        return next((a for a in self.agents if a.name == decision), None)\n\n    def delegate(self, task: str, **kwargs):\n        for agent in self.agents:\n            if agent.can_handle(task):\n                print(f\"[Supervisor] Delegating to {agent.name} via keyword match\")\n                return agent.handle(task, **kwargs)\n\n        # Fallback: use LLM to decide\n        selected = self.decide_agent(task)\n        if selected:\n            print(f\"[Supervisor] Delegating to {selected.name} via LLM decision\")\n            return selected.handle(task, **kwargs)\n\n        raise ValueError(f\"No agent found to handle task: {task}\")\n",
  "src\\model\\__init__.py": "",
  "src\\model\\agents\\git_agent.py": "# src/model/agents/git_agent.py\n\nimport subprocess\nimport os\nimport re\nimport ast\nfrom src.model.base_agent import BaseAgent\nfrom src.model.llm_client import LLMClient\nfrom src.model.utils.file_indexer import index_repo_files\n\nclass GitAgent(BaseAgent):\n    def __init__(self, repo_path: str, llm_client: LLMClient):\n        super().__init__(\"GitAgent\")\n        self.repo_path = repo_path\n        self.llm = llm_client\n        self.file_index = index_repo_files(self.repo_path)\n\n    def can_handle(self, task: str) -> bool:\n        task = task.lower()\n        return any(keyword in task for keyword in [\n            \"git\", \"code review\", \"commit\", \"project overview\", \"suggest improvement\"\n        ])\n\n    def handle(self, task: str, **kwargs):\n        if \"summary\" in task:\n            return self.summarize_latest_commit()\n        elif \"project overview\" in task:\n            return self.project_overview()\n        elif \"suggest improvement\" in task:\n            return self.suggest_improvements()\n        else:\n            return \"GitAgent: Task not recognized.\"\n\n    def summarize_latest_commit(self):\n        diff = self._get_latest_commit_diff()\n        prompt = f\"Review and summarize this Git commit:\\n\\n{diff}\"\n        return self.llm.query(prompt)\n\n    def project_overview(self):\n        structure = self._get_directory_structure()\n        prompt = f\"This is the file structure of a codebase:\\n\\n{structure}\\n\\nWhat is this project likely doing?\"\n        return self.llm.query(prompt)\n\n    def suggest_improvements(self):\n        structure = self._get_directory_structure()\n        prompt = f\"Here is the project structure:\\n\\n{structure}\\n\\nSuggest possible improvements to structure or code quality.\"\n        return self.llm.query(prompt)\n    \n    def print_file_index_preview(self, limit: int = 3, chars: int = 300):\n        print(f\"\\n[GitAgent] Previewing first {limit} indexed files:\\n\")\n        count = 0\n        for path, content in self.file_index.items():\n            print(f\"--- {path} ---\")\n            print(content[:chars] + (\"...\" if len(content) > chars else \"\"))\n            print()\n            count += 1\n            if count >= limit:\n                break\n\n        if count == 0:\n            print(\"No files were indexed.\")\n\n\n    def reindex_files(self):\n        from src.model.utils.file_indexer import index_repo_files\n        self.file_index = index_repo_files(self.repo_path, force_refresh=True)\n        print(\"[GitAgent] File index refreshed and cached.\")\n\n    def explain_function(self, function_name: str) -> str:\n            for path, content in self.file_index.items():\n                try:\n                    tree = ast.parse(content)\n                    for node in ast.walk(tree):\n                        if isinstance(node, ast.FunctionDef) and node.name == function_name:\n                            # Get full source code lines\n                            lines = content.splitlines()\n                            start_line = node.lineno - 1\n                            end_line = getattr(node, 'end_lineno', start_line + 1)\n\n                            # Extract function code block\n                            function_code = \"\\n\".join(lines[start_line:end_line])\n\n                            prompt = (\n                                f\"Here's a Python function called `{function_name}` from the file `{path}`:\\n\\n\"\n                                f\"```python\\n{function_code.strip()}\\n```\\n\\n\"\n                                \"Please explain in detail what this function does.\"\n                            )\n                            return self.llm.query(prompt)\n                except SyntaxError:\n                    continue\n\n            return f\"Function `{function_name}` not found in indexed files.\"\n    \n    def list_all_functions(self) -> list[dict]:\n        functions = []\n\n        for path, content in self.file_index.items():\n            try:\n                tree = ast.parse(content)\n                for node in ast.walk(tree):\n                    if isinstance(node, ast.FunctionDef):\n                        functions.append({\n                            \"name\": node.name,\n                            \"path\": path\n                        })\n            except SyntaxError:\n                continue\n\n        return functions\n\n    def _get_latest_commit_diff(self) -> str:\n        try:\n            result = subprocess.run(\n                [\"git\", \"show\", \"--stat\", \"--unified=1\"],\n                cwd=self.repo_path,\n                capture_output=True,\n                text=True,\n                check=True\n            )\n            return result.stdout\n        except subprocess.CalledProcessError as e:\n            return f\"[GitAgent Error] Could not retrieve commit diff:\\n{e.stderr or str(e)}\"\n\n\n    def _get_directory_structure(self) -> str:\n        output = []\n        for root, dirs, files in os.walk(self.repo_path):\n            depth = root.replace(self.repo_path, \"\").count(os.sep)\n            indent = \"  \" * depth\n            output.append(f\"{indent}{os.path.basename(root)}/\")\n            for f in files:\n                output.append(f\"{indent}  {f}\")\n        return \"\\n\".join(output)\n",
  "src\\model\\agents\\research_agent.py": "# src/model/agents/research_agent.py\n\nfrom src.model.base_agent import BaseAgent\nfrom src.model.llm_client import LLMClient\nfrom src.model.tools.internet_search import search_duckduckgo\nfrom src.model.utils.mongo_client import find_research, save_research\n\n\nclass ResearchAgent(BaseAgent):\n    def __init__(self, database: dict, llm_client: LLMClient):\n        super().__init__(\"ResearchAgent\")\n        self.database = database\n        self.llm = llm_client\n\n    def can_handle(self, task: str) -> bool:\n        return \"research\" in task.lower()\n\n    def handle(self, task: str, **kwargs):\n        query = kwargs.get(\"query\", task)\n\n        # Step 1: Check local database\n        result = self.search_database(query)\n        if self.is_enough_info(result):\n            return {\"source\": \"database\", \"content\": result}\n\n        # Step 2: Perform internet search\n        search_results = search_duckduckgo(query, max_results=5)\n        combined_snippets = \"\\n\\n\".join(search_results)\n\n        prompt = (\n            f\"You are a research assistant. Based on the following web search results, \"\n            f\"write a detailed summary about: '{query}'\\n\\n{combined_snippets}\"\n        )\n        summary = self.llm.query(prompt)\n\n        # Step 3: Save the summary to local DB (and eventually to vector store)\n        self.save_to_database(query, summary)\n\n        return {\"source\": \"internet\", \"content\": summary}\n\n    def search_database(self, query: str) -> str:\n        return find_research(query, max_age_days=7)\n\n    def is_enough_info(self, result: str) -> bool:\n        return bool(result and len(result.strip()) > 50)\n\n    def save_to_database(self, query: str, result: str):\n        save_research(query, result)\n",
  "src\\model\\agents\\__init__.py": "",
  "src\\model\\tools\\internet_search.py": "# src/model/tools/internet_search.py\n\nimport requests\nfrom duckduckgo_search import DDGS\nfrom bs4 import BeautifulSoup\nimport urllib.parse\nimport time\nprint(\"init\")\nHEADERS = {\n    \"User-Agent\": (\n        \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) \"\n        \"AppleWebKit/537.36 (KHTML, like Gecko) \"\n        \"Chrome/114.0.0.0 Safari/537.36\"\n    )\n}\n\ndef search_duckduckgo(query: str, max_results: int = 5) -> list[str]:\n    try:\n        with DDGS() as ddgs:\n            results = ddgs.text(query, max_results=max_results)\n            return [\n                f\"{r['title']} - {r['body']}\\n{r['href']}\"\n                for r in results\n            ]\n    except Exception as e:\n        print(f\"[DuckDuckGoSearch] Error: {e}\")\n        return [f\"[Search Error] {e}\"]",
  "src\\model\\utils\\file_indexer.py": "# src/model/utils/file_indexer.py\nimport os\nimport json\n\nEXCLUDED_DIRS = {\".git\", \".venv\", \"__pycache__\", \"node_modules\", \"data\"}\nEXCLUDED_FILES = {\".env\"}\nCACHE_FILE = \"data/file_index.json\"\n\ndef load_gitignore_patterns(repo_path: str) -> list:\n    gitignore_path = os.path.join(repo_path, \".gitignore\")\n    patterns = []\n    if os.path.exists(gitignore_path):\n        with open(gitignore_path, \"r\") as f:\n            for line in f:\n                line = line.strip()\n                if line and not line.startswith(\"#\"):\n                    patterns.append(line)\n    return patterns\n\n\ndef is_ignored(path: str, patterns: list) -> bool:\n    parts = path.split(os.sep)\n    \n    if any(part in EXCLUDED_DIRS for part in parts):\n        return True\n    if os.path.basename(path) in EXCLUDED_FILES:\n        return True\n    for pattern in patterns:\n        if pattern in path:\n            return True\n    return False\n\ndef index_repo_files(repo_path: str, force_refresh=False) -> dict:\n    os.makedirs(\"data\", exist_ok=True)\n\n    if os.path.exists(CACHE_FILE) and not force_refresh:\n        with open(CACHE_FILE, \"r\", encoding=\"utf-8\") as f:\n            return json.load(f)\n\n    file_index = {}\n    gitignore = load_gitignore_patterns(repo_path)\n\n    for root, _, files in os.walk(repo_path):\n        for filename in files:\n            rel_path = os.path.relpath(os.path.join(root, filename), repo_path)\n\n            if is_ignored(rel_path, gitignore):\n                continue\n\n            try:\n                with open(os.path.join(root, filename), \"r\", encoding=\"utf-8\") as f:\n                    content = f.read()\n                    file_index[rel_path] = content\n            except (UnicodeDecodeError, FileNotFoundError):\n                continue\n\n    # Save to cache\n    with open(CACHE_FILE, \"w\", encoding=\"utf-8\") as f:\n        json.dump(file_index, f, indent=2)\n\n    return file_index",
  "src\\model\\utils\\mongo_client.py": "# src/model/utils/mongo_client.py\nfrom datetime import datetime, timedelta\nfrom pymongo import MongoClient\nimport os\n\nMONGO_URI = os.getenv(\"MONGO_URI\", \"mongodb://admin:supersecret@localhost:27017/\")\nclient = MongoClient(MONGO_URI)\n\ndb = client[\"multiagent\"]\ncollection = db[\"research_cache\"]\n\n\ndef save_research(query: str, content: str):\n    collection.update_one(\n        {\"query\": query},\n        {\n            \"$set\": {\n                \"content\": content,\n                \"updated_at\": datetime.utcnow()\n            }\n        },\n        upsert=True\n    )\n\n\n\ndef find_research(query: str, max_age_days: int = 7):\n    doc = collection.find_one({\"query\": query})\n    if not doc:\n        return None\n\n    updated_at = doc.get(\"updated_at\")\n    if updated_at and datetime.utcnow() - updated_at > timedelta(days=max_age_days):\n        return None  # Too old\n\n    return doc[\"content\"]\n",
  "src\\model\\vector_store\\memory_store.py": "",
  "src\\routes\\knowledge.py": "from flask import Blueprint, jsonify\nfrom src.model.utils.mongo_client import collection\n\nbp = Blueprint(\"knowledge\", __name__, url_prefix=\"/api\")\n\n@bp.route(\"/knowledge\", methods=[\"GET\"])\ndef get_knowledge():\n    docs = collection.find({}, {\"_id\": 0, \"query\": 1, \"updated_at\": 1})\n    return jsonify(list(docs))\n",
  "src\\routes\\status.py": "# src/routes/status.py\nfrom flask import Blueprint, jsonify\n\nbp = Blueprint('status', __name__, url_prefix='/status')\n\n@bp.route('/', methods=['GET'])\ndef get_status():\n    return jsonify({\"status\": \"ok\"})\n",
  "src\\routes\\supervisorroute.py": "# src/routes/supervisorroute.py\n\nfrom flask import Blueprint, request, jsonify\nfrom src.model.supervisor import SupervisorAgent\n\nbp = Blueprint(\"supervisor\", __name__, url_prefix=\"/api\")\n\n# Singleton SupervisorAgent instance (optional: move to global state)\nsupervisor = SupervisorAgent()\n\n@bp.route(\"/ask-supervisor\", methods=[\"POST\"])\ndef ask_supervisor():\n    data = request.get_json()\n    task = data.get(\"task\")\n\n    if not task:\n        return jsonify({\"error\": \"Missing 'task' in request body\"}), 400\n\n    try:\n        result = supervisor.delegate(task)\n        return jsonify(result)\n    except Exception as e:\n        return jsonify({\"error\": str(e)}), 500\n",
  "src\\routes\\__init__.py": "",
  "tests_backend\\test_llm.py": "# test_llm.py\n\nfrom src.model.llm_client import LLMClient\n\ndef main():\n    llm = LLMClient()\n    prompt = \"Tell me a fun fact about space.\"\n    response = llm.query(prompt)\n    print(f\"LLM Response:\\n{response}\")\n\nif __name__ == \"__main__\":\n    main()\n"
}